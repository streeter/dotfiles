#!/bin/bash
# Configure the bash environment
#
# Chris Streeter <http://www.chrisstreeter.com>
#
# vim: ts=4 sts=4 shiftwidth=4 expandtab

# Debug slow startup
#set -x

# setup some basic variables
: ${HOME=~}
: ${LOGNAME=$(id -un)}
: ${UNAME=$(uname)}

# ----------------------------------------------------------------------
# CONFIGURATION
# ----------------------------------------------------------------------

# complete hostnames from
: ${HOSTFILE=~/.ssh/known_hosts}

# ----------------------------------------------------------------------
#  SHELL OPTIONS
# ----------------------------------------------------------------------

# Source global definitions
[ -f /etc/bashrc ] && source /etc/bashrc
[ -f /etc/bash.bashrc ] && source /etc/bash.bashrc
[ -f /rc/etc/dotfiles/system.bashrc ] && source /rc/etc/dotfiles/system.bashrc

# notify of bg job completion immediately
set -o notify

# Prevent file overwrite on stdout redirection
# Use `>|` to force redirection to an existing file
set -o noclobber

# Automatically trim long paths in the prompt (requires Bash 4.x)
PROMPT_DIRTRIM=2

# Enable history expansion with space
# E.g. typing !!<space> will replace the !! with your last command
bind Space:magic-space

# Turn on recursive globbing (enables ** to recurse all directories)
shopt -s globstar 2> /dev/null

# Case-insensitive globbing (used in pathname expansion)
shopt -s nocaseglob

## SMARTER TAB-COMPLETION (Readline bindings) ##

# Perform file completion in a case insensitive fashion
bind "set completion-ignore-case on"

# Treat hyphens and underscores as equivalent
bind "set completion-map-case on"

# Display matches for ambiguous patterns at first tab press
bind "set show-all-if-ambiguous on"

## SANE HISTORY DEFAULTS ##

# Append to the history file, don't overwrite it
shopt -s histappend

# Save multi-line commands as one command
shopt -s cmdhist

# Enable incremental history search with up/down arrows (also Readline goodness)
# Learn more about this here: http://codeinthehole.com/writing/the-most-important-command-line-tip-incremental-history-searching-with-inputrc/
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'
bind '"\e[C": forward-char'
bind '"\e[D": backward-char'

# shell opts. see bash(1) for details
shopt -s extglob >/dev/null 2>&1
shopt -s hostcomplete >/dev/null 2>&1
shopt -s interactive_comments >/dev/null 2>&1
shopt -u mailwarn >/dev/null 2>&1
shopt -s no_empty_cmd_completion >/dev/null 2>&1

## BETTER DIRECTORY NAVIGATION ##

# Prepend cd to directory names automatically
shopt -s autocd 2> /dev/null
# Correct spelling errors during tab-completion
shopt -s dirspell 2> /dev/null
# Correct spelling errors in arguments supplied to cd
shopt -s cdspell 2> /dev/null

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# fuck that you have new mail shit
unset MAILCHECK

# default umask (mask out permissions on new files)
umask 0022

# ----------------------------------------------------------------------
# PATH
# ----------------------------------------------------------------------

# we want the various sbins on the path along with /usr/local/bin
PATH="/usr/local/bin:$PATH:/usr/local/sbin:/usr/sbin:/sbin"

PATH="$HOME/bin:$PATH"

test -d "/usr/local/share/npm/bin" &&
    PATH="$PATH:/usr/local/share/npm/bin"

POSTGRESAPP="/Applications/Postgres.app/Contents/Versions/latest/bin"
if [ -e $POSTGRESAPP ]; then
    PATH="$PATH:$POSTGRESAPP"
fi
unset POSTGRESAPP

export PATH


# ----------------------------------------------------------------------
# AWS
# ----------------------------------------------------------------------

AWS_HOME="${HOME}/.aws"

if [ -e $AWS_HOME ]; then
    export AWS_HOME
    export AWS_CONFIG_FILE="${AWS_HOME}/config"

    # Grab the last set values in the config file
    export AWS_DEFAULT_OUTPUT=$(grep '^output' ${AWS_CONFIG_FILE} | cut -d= -f2 | tr -d ' ' | tail -1)
    #export AWS_DEFAULT_REGION=$(grep '^region' ${AWS_CONFIG_FILE} | cut -d= -f2 | tr -d ' ' | tail -1)
    #export AWS_ACCESS_KEY_ID=$(grep '^aws_access_key_id' ${AWS_CONFIG_FILE} | cut -d= -f2 | tr -d ' ' | tail -1)
    #export AWS_SECRET_ACCESS_KEY=$(grep '^aws_secret_access_key' ${AWS_CONFIG_FILE} | cut -d= -f2 | tr -d ' ' | tail -1)

    awsactivate () {
        echo "Activating the AWS environment for $1..."
        export AWS_DEFAULT_PROFILE="${1}"

        for key in "AWS_ACCESS_KEY_ID" "AWS_SECRET_ACCESS_KEY" "REGION"; do
            value=`\\python <<EOF
import ConfigParser
import os

config_file = os.environ['AWS_CONFIG_FILE']
cred_file = os.path.join(os.path.dirname(config_file), 'credentials')

config = ConfigParser.RawConfigParser()
config.read(config_file)

creds = ConfigParser.RawConfigParser()
creds.read(cred_file)

key = '${key}'.lower()

try:
    print creds.get('${1}', key)
except ConfigParser.NoOptionError:
    print config.get('profile ${1}', key)
EOF`
            export $key="${value}"
        done

        export AWS_DEFAULT_REGION="${REGION}"
    }
fi

unset AWS_HOME

# ----------------------------------------------------------------------
# ENVIRONMENT CONFIGURATION
# ----------------------------------------------------------------------

# detect interactive shell
case "$-" in
    *i*) INTERACTIVE=1 ;;
    *)   unset INTERACTIVE ;;
esac

# detect login shell
case "$0" in
    -*) LOGIN=1 ;;
    *)  unset LOGIN ;;
esac

# enable en_US locale w/ utf-8 encodings if not already configured
: ${LANG:="en_US"}
: ${LANGUAGE:="en"}
: ${LC_CTYPE:="en_US.UTF-8"}
: ${LC_ALL:="en_US.UTF-8"}
export LANG LANGUAGE LC_CTYPE LC_ALL

# ignore backups, CVS directories, python bytecode, vim swap files
FIGNORE="~:CVS:#:.pyc:.swp:.swa"


# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"



# ----------------------------------------------------------------------
# MACOS X / DARWIN SPECIFIC
# ----------------------------------------------------------------------

if [ "$UNAME" = Darwin ]; then
    test -x /usr/pkg && {
        PATH="/usr/pkg/sbin:/usr/pkg/bin:$PATH"
        MANPATH="/usr/pkg/share/man:$MANPATH"
    }
fi

# ----------------------------------------------------------------------
# BASH COMPLETION
# ----------------------------------------------------------------------

if test -z "$BASH_COMPLETION" ; then
    bash=${BASH_VERSION%.*}; bmajor=${bash%.*}; bminor=${bash#*.}
    if [ "$PS1" ] && [ $bmajor -gt 1 ] ; then
        # search for a bash_completion file to source
        for f in /usr/pkg/etc/back_completion \
            /usr/local/etc/bash_completion \
            /etc/bash_completion \
            ~/.bash_completion ;
        do
            test -f $f && {
                . $f
                break
            }
        done
    fi
    unset bash bmajor bminor
fi

# override and disable tilde expansion
_expand() {
    return 0
}

# ----------------------------------------------------------------------
# PYTHON STARTUP / AUTO-COMPLETION
# ----------------------------------------------------------------------
export PYTHONSTARTUP="$HOME/.pystartup"

# ----------------------------------------------------------------------
# LS AND DIRCOLORS
# ----------------------------------------------------------------------

# we always pass these to ls(1)
LS_COMMON="-BG"

# if the dircolors utility is available, set that up to
dircolors="$(type -P gdircolors dircolors | head -1)"
test -n "$dircolors" && {
    COLORS=/etc/DIR_COLORS
    test -e "/etc/DIR_COLORS.$TERM"   && COLORS="/etc/DIR_COLORS.$TERM"
    test -e "$HOME/.dircolors"        && COLORS="$HOME/.dircolors"
    test ! -e "$COLORS"               && COLORS=
    eval `$dircolors --sh $COLORS`
}
unset dircolors

# setup the main ls alias if we've established common args
test -n "$LS_COMMON" &&
alias ls="command ls $LS_COMMON"


# -------------------------------------------------------------------
# EXPORTS
# -------------------------------------------------------------------

source "$HOME/.exports"

test -f "$HOME/.exports.private" &&
source "$HOME/.exports.private"


# -------------------------------------------------------------------
# PROMPT
# -------------------------------------------------------------------

source "$HOME/.bash_prompt"

# -------------------------------------------------------------------
# USER SHELL ENVIRONMENT
# -------------------------------------------------------------------

# Use the color prompt by default when interactive
test -n "$PS1" &&
prompt_color

# -------------------------------------------------------------------
# MOTD / FORTUNE
# -------------------------------------------------------------------

#test -n "$INTERACTIVE" -a -n "$LOGIN" && {
#    uname -npsr
#    uptime
#}

# -------------------------------------------------------------------
# RVM
# -------------------------------------------------------------------
if [[ -s "$HOME/.rvm/scripts/rvm" ]]; then
    # Load RVM into a shell session *as a function*
    source "$HOME/.rvm/scripts/rvm"

    # Add RVM to PATH for scripting
    export PATH="$PATH:$HOME/.rvm/bin"
fi

# ----------------------------------------------------------------------
# ALIASES / FUNCTIONS
# ----------------------------------------------------------------------

# User specific aliases and functions
source "$HOME/.alias"

source "$HOME/.functions"

# -------------------------------------------------------------------
# POST CONFIGURATION HOOKS
# -------------------------------------------------------------------

# Python virtualenvwrapper Setup
export VIRTUAL_ENV_DISABLE_PROMPT=true
export WORKON_HOME="${HOME}/.virtualenvs"
export PIP_VIRTUALENV_BASE=$WORKON_HOME
export PIP_RESPECT_VIRTUALENV=true
export PIP_REQUIRE_VIRTUALENV=true

gpip() {
   PIP_REQUIRE_VIRTUALENV="" pip "$@"
}

if [ -d "${HOME}/.bashrc.d" ]; then
    for f in ${HOME}/.bashrc.d/*.bashrc; do
        source "$f"
    done
fi
