# -*- coding: utf-8 -*-
#
# Best goddamn .pythonrc file in the whole world.
#
# Authors:
#   Ben O'Hara <bohara@gmail.com>
#   Chris Streeter <chris@chrisstreeter.com>
#

# Imports we need
import sys
import os
import readline
import rlcompleter
import atexit
import pprint


# Color Support
class TermColors(dict):
    """Gives easy access to ANSI color codes. Attempts to fall back to no color
    for certain TERM values. (Mostly stolen from IPython.)"""

    COLOR_TEMPLATES = (
        ("Black", "0;30"),
        ("Red", "0;31"),
        ("Green", "0;32"),
        ("Brown", "0;33"),
        ("Blue", "0;34"),
        ("Purple", "0;35"),
        ("Cyan", "0;36"),
        ("LightGray", "0;37"),
        ("DarkGray", "1;30"),
        ("LightRed", "1;31"),
        ("LightGreen", "1;32"),
        ("Yellow", "1;33"),
        ("LightBlue", "1;34"),
        ("LightPurple", "1;35"),
        ("LightCyan", "1;36"),
        ("White", "1;37"),
        ("Normal", "0"),
    )

    NoColor = ''
    _base = '\001\033[%sm\002'

    def __init__(self):
        if os.environ.get('TERM') in ('xterm-color', 'xterm-256color', 'linux',
                                    'screen', 'screen-256color', 'screen-bce'):
            self.update(dict([(k, self._base % v) for k, v in self.COLOR_TEMPLATES]))
        else:
            self.update(dict([(k, self.NoColor) for k, v in self.COLOR_TEMPLATES]))
_c = TermColors()


# Enable Color Prompts
sys.ps1 = "%s>>> %s" % (_c['Green'], _c['Normal'])
sys.ps2 = "%s... %s" % (_c['Red'], _c['Normal'])


# Enable Pretty Printing for stdout
def my_displayhook(value):
    if value is not None:
        try:
            import __builtin__
            __builtin__._ = value
        except ImportError:
            __builtins__._ = value

        pprint.pprint(value)
sys.displayhook = my_displayhook


class irlcompleter(rlcompleter.Completer):
    def complete(self, text, state):
        if text == '':
            return ['  ', None][state]
        else:
            return rlcompleter.Completer.complete(self, text, state)


# Enable a History
historyPath = os.path.expanduser('~/.pyhistory')
readline.parse_and_bind('tab: complete')
readline.set_completer(irlcompleter().complete)

# Set maximum number of items that will be written to the history file
readline.set_history_length(1000)


def save_history(historyPath=historyPath):
    import readline
    readline.write_history_file(historyPath)

if os.path.exists(historyPath):
    readline.read_history_file(historyPath)

atexit.register(save_history)
del os, atexit, readline, rlcompleter, save_history, historyPath
